TODO
====

 * multiplication mod N; ( a * b ) mod N = ( a mod N * b mod N ) mod N, or is there something fancier?
 * modular multiplication (Kochanski, Montgomery)

 * sieve : With N = 2^32, N/ln(N) yields 193635250 primes. I guess base_t division will suffice for subset of primes? ]
 * sieve : Perhaps make an int jans::big_int::extract( big_int & num, int & ln, base_t factor ); x = extract( n_in, f ); --> n_out * f^x = n_in and ( n_out mod f ) == 0 ]

 * Use an actual sieve instead of division
 *    S_k: x so that ceil( sqrt(kN) ) <= x <= ceil (sqrt((k+1)N) - 1 < sqrt((k+1)N)
 *    For x in S_k: x*x mod N = x*x - kN, which lends itself to list sieving


Pomerance ( http://websites.math.leidenuniv.nl/algebra/sieving.pdf )
--------------------------------------------------------------------

The problem is that you want to sieve for presence of prime factors in x * x mod N, with ceil(sqrt( N )) <= x < ceil(sqrt( 2 * N )) and hence x * x mod N = x * x - N, without actually computing the expensive x * x or x * x mod N. The a_i allow this.

The p in 2 < p <= B are searched so that [ a * a = N ] mod p contains 2 solutions a_1 and a_2. The number of solutions of [ a * a = N ] mod p can be zero, one or two. If there is one solution, then p | N, so this typically doesn't happen. The cases of zero and two solutions occur - apparently - with about equal probability.

The x's are sieved based on [ x = a_i ] mod p, hence augmenting s and t in x = a_1 + s * p and x = a_2 + t * p.

For such x, it holds that [ x * x mod N ] mod p = [ a_i * a_i + 2 * p * a_i + p * p - N ] mod p = [ a_i * a_i - N ] mod p = 0.

Conversely, any x can be written as x = q * p + r. What does [ x * x mod N ] mod p = 0 tell us about r?

It holds that 0 = [ x * x mod N ] mod p = [ x * x - N ] mod p = [ q * q * p * p + 2 * p * q * r + r * r - N ] mod p = [ r * r - N ] mod p.

Additional info:
 * https://crypto.stackexchange.com/questions/35590/sieving-the-sequence-x2-n-to-recognize-b-smooth-numbers
 * https://crypto.stackexchange.com/questions/35615/in-the-quadratic-sieve-why-restrict-the-factor-base

In particular: Sieve integers of the form (a*x+b)^2 - n, with (a,b) chosen appropriately, in particular such that (a*x+b)^2 - n is divisible by a (allowing a as a factor, if it does not belong to the factor base). This is what actually used variants of the Multiple Polynomial Quadratic Sieve do. The multiple polynomials allows to remain in the region where the un-factored part of what's sieved is small, so that the rate of finding smooth does not become vanishingly small. One advantage compared to the previous solution is that the factor base used for sieving is the same for all the polynomials used.

It seems that popular variants of the QS are looking for smooth only of the form x^2 - N with x = a*y + b, for appropriately chosen a and b; in particular, such that a divides (a*y+b)^2-N. That allows to restrict the factor base without lowering the performance of sieving. Restricting the factor base is good because it about halves the number of variables in the system of linear equations to be solved; and about halves the number of smooths to be found before a solution to such system can be found.

So: implement the Multiple Polynomial Quadratic Sieve with a = 1 and b = 0 as an option?

